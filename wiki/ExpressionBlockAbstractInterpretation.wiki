#summary Algorithm for Generating MC from Expression blocks
<wiki:toc max_depth="3" />

= Details =

Below you can find the algorithm for converting the C.F.G flow points along with the Syntax Tree to A.C.F.G (Annotated Control Flow Graph, this is a C.F.G that on its edges you can find MCs)

== Assumptions ==
 * We handle expression of the following format x = ay +b (a,b constants, x and y are variables)
 
== Notations ==
 # val(*f*) 
   A mapping, : *v* -> *value*, from variable names to their values, which is "attached" to flow point *f*.
 # *current*
   A "temporary" mapping, : *v* -> *value* between variable names to their values.
 # *current(x)*
   The value of *x* in the *current* map.
 # *ex(x)*
   Reference to all occurrences of the variable *x* in the expression *ex*.
   i.e. *ex(x)* <-- *5* , is equivalent to replacing all occurrences of *x* in *ex* with the value *5*.
 # *MC(e)*
   The Monotonicity Constraints graph associated with an edge *e* of the CFG.
 # *invariants* - tuple in the following form <x1,o,x2> where o is on of {>,>=,<,<=,=}

== Sub Functions/Procedures ==
 # *UNIQUE_UNDEFINED_VALUE*()
   A function returning a uniquely identified undefined value. Each call to it returns a new never used before identifier which can be recognized as "Undefined". an "Undefined" value for a variable means that the variable has a value, but the value is either not-known or can't be deterministically computed. This can happen, for example, when variables are used without being initialized. 
 # *EVALUATE(ex, val)*
   A function which evaluates an expression *ex* and returns an expression which can be either:
    # A constant value.
    # An undefined uniquely identified value.
    # A simplified expression containing constant values and/or undefined values at it's leafs. The *val* parameter is a mapping *v* -> *value*, between variable names and their expressions.
   The function does the following:
   * *EVALUATE(ex, val)*
     # For each variable *x* in *ex*:
        # if *val* does not contain a value for *x* Then: *val*(*x*) <-- *UNIQUE_UNDEFINED_VALUE*()
        # *ex*(*x*) <-- *val*(*x*)
     # *ex2* <-- Simplify and evaluate *ex*
     # Return *ex2*
     # END
 # *MERGE(target, source)*
   The *target* and *source* parameters are mappings *v -> value*, like *current*. The MERGE function merges *source* into *target*. The procedure does the following:
   * *MERGE(target, source)*
      # If *target* is empty copy source to target and return.
      # For each variable *x* which has a value in *source*, Do:
         # If *target* value for *x* and *target*(*x*) is not identical to *source*(*x*)
            # *target*(*x*) <-- *UNIQUE_UNDEFINED_VALUE*()
      # END
 # *COMPUTE_MC_GRAPH(e,inValues,outValues)*
   The *e* is the edge to compute its MC that is attached to the edge,*inValues* and *outValues* are mapping *v* -> *value*, between variable names and their expressions. 
   # For each *xOut* in outValue
     # For each *yIn* in inValue 
       # diff <- EVALUATE((xOut - yIn),outValue)
       # if diff is not constant value then continue to next iteration.
       # if diff > 0 add strict edge xOut -> yIn to MC(e)
       # if diff < 0 add strict edge yIn -> xOut to MC(e)
       # if diff = 0 add non stricts edges xOut->yIn and yIn -> xOut to MC(e)
 
 # *COMPUTE-LOGICAL-CLOSURE(f,g,mc)* - *f* and *g* are source and target flowpoints, *mc* is the MC that is attached to the edge *f->g*
   # add arcs that represents f's invariants.
   # add arcc that represents g's invariants.
   # for each edge on the mc put weight
     # if the edge is strict than wight is -1 otherwise 0.
   # if mc contains negative cycle return error.
   # for each u,v in mc's vertices do
      # compute short path between u,v if there is no path continue to next pair.
      # if the path is negative then add strict arc between u->v to mc
      # else add non strict arc u->v to mc

== Algorithm ==
 # emptyMC <- empty MC with all the constants and known variables
 # For each flow point *f* in the CFG:
     # val(*f*) <-- {}  (initialize to empty map)
 # changed <- false.
 # While edge MC was changed, Do:
   # chnaged <- false 
   # Perform D.F.S and for each discovered edge *e*:
     ## *start vertex(f)* - if this is the first run of D.F.S initialize all variables of *val(f)* to be undefined values.
     ## *examine edge(e)* - 
        ## *f* <-- source(*e*)
        ## *g* <-- target(*e*)
        ## *current* <-- val(*f*)
        ## newMC <- emptyMC
        ## If *f* is an expression block Then:
           # For each expression *ex*, which changes variable *y*, in the expression block of *f* Do:
              ## For each variable *x* in *ex*:  
                 # If *current* does not contain *x* Then: *current(x)* <-- *UNIQUE_UNDEFINED_VALUE*()
                 # *ex(x)* <-- *current(x)* 
              ## *current(y)* <-- *EVALUATE(ex, current)*
        ## else (this is a branch flowpoint)
           # logicalExpTree <-- logic(f)
           # if complement edge (logical expression is false)
             # logicalExpTree <-- compute complement for the logic tree.
           # invariants <-- convert tree logical tree to invariants(logicalExpTree)
           # for each invariant in INVARIANTS(f)
             # add edge to MC(e)
        ## newMC <- *COMPUTE_MC_GRAPH*(*e*,*val(f)*,*current*)
        ## if newMC != MC(e)
           # MC(e) <- newMC
           # changed <- true.
        ## *MERGE*(val(*g*), *current*)
 # For each edge in  CFG do 
   ## COMPUTE-LOGICAL-CLOSURE(source(e),target(e),MC(e))
 # END

== Remarks on Algorithm ==
 # DFS *Forward*, *Cross*, *Back* and *Tree* edges are defined as in the following image:
   http://upload.wikimedia.org/wikipedia/en/thumb/5/57/Tree_edges.svg/412px-Tree_edges.svg.png
 # The line "While there exists a Flow Point *h* s.t. tag(*h*) = *dirty* , Do:" can be implemented by doing exactly 2 runs of the DFS.

== Ideas == 

 #  We check that the in degree of the target flow point is equal to 1 since we cannot know what is the new value for example the following program: 
  {{{ 
      x = y;
      if ()
          x = 100;
      else 
          x = 5;
      z = 3*x - 100;
  }}}
  then if we got from the if block (x = 100) we know that z > x but if we got from else 
  block then z < x.
 # If the value of some variable (y) is unknown then assign the recent equation of (y) and simplify the equation. Then, assign the equation to x.
 # We need to think what to do about back edges. For example, in the following program:
 {{{
     y = 5
     x = 5;
     while (x > 0)
         x--;
     y = x+1;
 }}}
   If we would not consider the back-edge from '*x--*' FP to the '*while*' FP, it would seem that the value of y has grown after the command '*y = x+5*', where in fact its value is smaller. Since there is a back edge which changes the value of '*x*', the value of '*x*' must be "reset" to "*Undefined*". Since the DFS/BFS edges order is not predetermined we can't guarantee that the loop edge will be examined before the edge going "out" of the loop (from the '*while*' FP to the '*y = x+1*' command FP).