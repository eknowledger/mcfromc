#summary Algorithm for Generating MC from Expression blocks
<wiki:toc max_depth="3" />

= Details =

Below you can find the algorithm for converting the C.F.G flow points along with the Syntax Tree to A.C.F.G (Annotated Control Flow Graph, this is a C.F.G that on its edges you can find MCs)

== Assumptions ==
 * We handle expression of the following format x = ay +b (a,b constants, x and y are variables)
== Algorithm == 
 # Initialize map with all known variables to UNKNOWN (maybe INFINITE)
 # Add empty MCs to all C.F.G edges.
 # Perform D.F.S and while examining edges do the following:
     ## f <- source(e)
     ## g <- target(e)
     ## current <- map of f
     ## for each expression in the expression block of f do
           ## replace the variables with their values according to the current map.
           ## evaluate the expression
           ## set the new value in the map.
     ## if the number of in edges of g = 1 then copy the map of variable values from current to g.

== Ideas == 

 #  We check that the in degree of the target flow point is equal to 1 since we cannot know what is the new value for example the following program: 
  {{{ 
      x = y;
      if ()
          x = 100;
      else 
          x = 5;
      z = 3*x - 100;
  }}}
  then if we got from the if block (x = 100) we know that z > x but if we got from else 
  block then z < x.
 # If the value of some variable (y) is unknown then assign the recent equation of (y) and simplify the equation. Then, assign the equation to x.
 # Maybe deal only with unsigned int where negative values are considered as underflow. 
 # We need to think what to do about back edges. For example, in the following program:
 {{{
     y = 5
     x = 5;
     while (x > 0)
         x--;
     y = x+1;
 }}}
   If we would not consider the back-edge from '*x--*' FP to the '*while*' FP, it would seem that the value of y has grown after the command '*y = x+5*', where in fact its value is smaller. Since there is a back edge which changes the value of '*x*', the value of '*x*' must be "reset" to "*Undefined*". Since the DFS/BFS edges order is not predetermined we can't guarantee that the loop edge will be examined before the edge going "out" of the loop (from the '*while*' FP to the '*y = x+1*' command FP).