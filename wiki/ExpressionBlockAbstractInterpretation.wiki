#summary Algorithm for Generating MC from Expression blocks
<wiki:toc max_depth="3" />

= Details =

Below you can find the algorithm for converting the C.F.G flow points along with the Syntax Tree to A.C.F.G (Annotated Control Flow Graph, this is a C.F.G that on its edges you can find MCs)

== Assumptions ==
 * We handle expression of the following format x = ay +b (a,b constants, x and y are variables)
== Algorithm == 
 # Initialize map with all known variables to UNKNOWN (maybe INFINITE)
 # Add empty MCs to all C.F.G edges.
 # Perform D.F.S and while examining edges do the following:
     ## f <- source(e)
     ## g <- target(e)
     ## current <- map of f
     ## for each expression in the expression block of f do
           ## replace the variables with their values according to the current map.
           ## evaluate the expression
           ## set the new value in the map.
     ## if the number of in edges of g = 1 then copy the map of variable values from current to g.

== Ideas == 

 #  We check that the in degree of the target flow point is equal to 1 since we cannot know what is the new value for example the following program: 
  {{{ 
      x = y;
      if ()
          x = 100;
      else 
          x = 5;
      z = 3*x - 100;
  }}}
  then if we got from the if block (x = 100) we know that z > x but if we got from else 
  block then z < x.
 # If the value of some variable (y) is unknown then assign the recent equation of (y) and simplify the equation. Then, assign the equation to x.
 # Maybe deal only with unsigned int where negative values are considered as underflow. 
 # We need to think what to do about back edges. For example, in the following program:
 {{{
     y = 5
     x = 5;
     while (x > 0)
         x--;
     y = x+1;
 }}}
   If we would not consider the back-edge from '*x--*' FP to the '*while*' FP, it would seem that the value of y has grown after the command '*y = x+5*', where in fact its value is smaller. Since there is a back edge which changes the value of '*x*', the value of '*x*' must be "reset" to "*Undefined*". Since the DFS/BFS edges order is not predetermined we can't guarantee that the loop edge will be examined before the edge going "out" of the loop (from the '*while*' FP to the '*y = x+1*' command FP).
 # Idea for algorithm(work in progress):
    Denote: inVal(*e*) = map of edge *e* entrance variable values.  
            outVal(*e*) = map of edge *e* exit variable values.  
    ## Run DFS on graph:
       # When encountering any edge, mark it as "Dirty".
       # When encountering a back-edge *e* (an edge closing a loop in the CFG):
         # Mark edge as "back-edge".
    # While there are edges marked as "Dirty":
      # Run DFS on graph, evaluating size-change on all edges, as described in the basic algorithm above:
        # Evaluate size-change on edges marked as "Dirty". After doing so, mark them as "Clean".
        # If a FP *f* has an in-edge which is marked "Dirty", mark all it's out-edges as "Dirty"
        # When encountering a FP *f* with an in-edge *b* which is marked as "back-edge":
          # For each variable *x* which participates in outVal(*b*) :
            # For each out-edge *e* of *f*:
              # if inVal(*e*) contains *x*, Then: 
                # Remove *x* from inVal(*e*).
                # Mark *e* as "Dirty".